#![no_std]

// Architecture-specific definitions
pub mod arch;
pub use arch::*;

// Complex structures that are used for some system calls
pub mod data;
pub use data::*;

// All errors that can be generated by a system call
pub mod error;
pub use error::*;

// Flags used as an argument to many system calls
pub mod flag;
pub use flag::*;

// Functions for low level hardware control
pub mod io;
pub use io::*;

// Call numbers used by each system call
pub mod number;
pub use number::*;

// ABI for shared memory based signals
pub mod sigabi;
pub use sigabi::*;

// V2 scheme format
pub mod schemev2;
pub use schemev2::*;

// Directory entries
pub mod dirent;
pub use dirent::*;

// High-level call functions are defined inline below (after syscall0..6).

// ---------------------------------------------------------------------------
// Syscall raw invocation functions (x86_64 syscall ABI)
// ---------------------------------------------------------------------------
// Instead of a deeply-nested macro (which recent Rust nightlies have trouble
// parsing), each function is written out explicitly. There are only 7 variants
// (0..6 arguments) so the duplication is negligible and much more readable.

#[cfg(feature = "userspace")]
pub unsafe fn syscall0(mut a: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall1(mut a: usize, b: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall4(
    mut a: usize,
    b: usize,
    c: usize,
    d: usize,
    e: usize,
) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        in("r10") e,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall5(
    mut a: usize,
    b: usize,
    c: usize,
    d: usize,
    e: usize,
    f: usize,
) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        in("r10") e,
        in("r8") f,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall6(
    mut a: usize,
    b: usize,
    c: usize,
    d: usize,
    e: usize,
    f: usize,
    g: usize,
) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        in("r10") e,
        in("r8") f,
        in("r9") g,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

// High-level syscall functions
#[cfg(feature = "userspace")]
pub mod call {
    use super::*;

    /// Close a file
    pub fn close(fd: usize) -> error::Result<usize> {
        unsafe { syscall1(number::SYS_CLOSE, fd) }
    }

    /// Get the current system time
    pub fn clock_gettime(clock: usize, tp: &mut data::TimeSpec) -> error::Result<usize> {
        unsafe {
            syscall2(
                number::SYS_CLOCK_GETTIME,
                clock,
                tp as *mut data::TimeSpec as usize,
            )
        }
    }

    /// Copy and transform a file descriptor
    pub fn dup(fd: usize, buf: &[u8]) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_DUP, fd, buf.as_ptr() as usize, buf.len()) }
    }

    /// Copy and transform a file descriptor
    pub fn dup2(fd: usize, newfd: usize, buf: &[u8]) -> error::Result<usize> {
        unsafe {
            syscall4(
                number::SYS_DUP2,
                fd,
                newfd,
                buf.as_ptr() as usize,
                buf.len(),
            )
        }
    }

    /// Change file permissions
    pub fn fchmod(fd: usize, mode: u16) -> error::Result<usize> {
        unsafe { syscall2(number::SYS_FCHMOD, fd, mode as usize) }
    }

    /// Change file ownership
    pub fn fchown(fd: usize, uid: u32, gid: u32) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_FCHOWN, fd, uid as usize, gid as usize) }
    }

    /// Change file descriptor flags
    pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_FCNTL, fd, cmd, arg) }
    }

    /// Map a file into memory, but with the ability to set the address to map into, either as a hint
    /// or as a requirement of the map.
    ///
    /// # Errors
    /// `EACCES` - the file descriptor was not open for reading
    /// `EBADF` - if the file descriptor was invalid
    /// `ENODEV` - mmapping was not supported
    /// `EINVAL` - invalid combination of flags
    /// `EEXIST` - if [`MapFlags::MAP_FIXED`] was set, and the address specified was already in use.
    ///
    pub unsafe fn fmap(fd: usize, map: &data::Map) -> error::Result<usize> {
        syscall3(
            number::SYS_FMAP,
            fd,
            map as *const data::Map as usize,
            core::mem::size_of::<data::Map>(),
        )
    }

    /// Unmap whole (or partial) continous memory-mapped files
    pub unsafe fn funmap(addr: usize, len: usize) -> error::Result<usize> {
        syscall2(number::SYS_FUNMAP, addr, len)
    }

    /// Retrieve the canonical path of a file
    pub fn fpath(fd: usize, buf: &mut [u8]) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_FPATH, fd, buf.as_mut_ptr() as usize, buf.len()) }
    }

    /// Create a link to a file
    pub fn flink<T: AsRef<str>>(fd: usize, path: T) -> error::Result<usize> {
        let path = path.as_ref();
        unsafe { syscall3(number::SYS_FLINK, fd, path.as_ptr() as usize, path.len()) }
    }

    /// Rename a file
    pub fn frename<T: AsRef<str>>(fd: usize, path: T) -> error::Result<usize> {
        let path = path.as_ref();
        unsafe { syscall3(number::SYS_FRENAME, fd, path.as_ptr() as usize, path.len()) }
    }

    /// Get metadata about a file
    pub fn fstat(fd: usize, stat: &mut data::Stat) -> error::Result<usize> {
        unsafe {
            syscall3(
                number::SYS_FSTAT,
                fd,
                stat as *mut data::Stat as usize,
                core::mem::size_of::<data::Stat>(),
            )
        }
    }

    /// Get metadata about a filesystem
    pub fn fstatvfs(fd: usize, stat: &mut data::StatVfs) -> error::Result<usize> {
        unsafe {
            syscall3(
                number::SYS_FSTATVFS,
                fd,
                stat as *mut data::StatVfs as usize,
                core::mem::size_of::<data::StatVfs>(),
            )
        }
    }

    /// Sync a file descriptor to its underlying medium
    pub fn fsync(fd: usize) -> error::Result<usize> {
        unsafe { syscall1(number::SYS_FSYNC, fd) }
    }

    /// Truncate or extend a file to a specified length
    pub fn ftruncate(fd: usize, len: usize) -> error::Result<usize> {
        unsafe { syscall2(number::SYS_FTRUNCATE, fd, len) }
    }

    // Change modify and/or access times
    pub fn futimens(fd: usize, times: &[data::TimeSpec]) -> error::Result<usize> {
        unsafe {
            syscall3(
                number::SYS_FUTIMENS,
                fd,
                times.as_ptr() as usize,
                times.len() * core::mem::size_of::<data::TimeSpec>(),
            )
        }
    }

    /// Fast userspace mutex
    pub unsafe fn futex(
        addr: *mut i32,
        op: usize,
        val: i32,
        val2: usize,
        addr2: *mut i32,
    ) -> error::Result<usize> {
        syscall5(
            number::SYS_FUTEX,
            addr as usize,
            op,
            (val as isize) as usize,
            val2,
            addr2 as usize,
        )
    }

    /// Seek to `offset` bytes in a file descriptor
    pub fn lseek(fd: usize, offset: isize, whence: usize) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_LSEEK, fd, offset as usize, whence) }
    }

    /// Make a new scheme namespace
    pub fn mkns(schemes: &[[usize; 2]]) -> error::Result<usize> {
        unsafe { syscall2(number::SYS_MKNS, schemes.as_ptr() as usize, schemes.len()) }
    }

    /// Change mapping flags
    pub unsafe fn mprotect(
        addr: usize,
        size: usize,
        flags: flag::MapFlags,
    ) -> error::Result<usize> {
        syscall3(number::SYS_MPROTECT, addr, size, flags.bits() as usize)
    }

    /// Sleep for the time specified in `req`
    pub fn nanosleep(req: &data::TimeSpec, rem: &mut data::TimeSpec) -> error::Result<usize> {
        unsafe {
            syscall2(
                number::SYS_NANOSLEEP,
                req as *const data::TimeSpec as usize,
                rem as *mut data::TimeSpec as usize,
            )
        }
    }

    /// Open a file at a specific path
    pub fn openat<T: AsRef<str>>(
        fd: usize,
        path: T,
        flags: usize,
        fcntl_flags: usize,
    ) -> error::Result<usize> {
        let path = path.as_ref();
        unsafe {
            syscall5(
                number::SYS_OPENAT,
                fd,
                path.as_ptr() as usize,
                path.len(),
                flags,
                fcntl_flags,
            )
        }
    }

    /// Open a file at a specific path with filter
    pub fn openat_with_filter<T: AsRef<str>>(
        fd: usize,
        path: T,
        flags: usize,
        fcntl_flags: usize,
        euid: u32,
        egid: u32,
    ) -> error::Result<usize> {
        let path = path.as_ref();
        unsafe {
            syscall6(
                number::SYS_OPENAT_WITH_FILTER,
                fd,
                path.as_ptr() as usize,
                path.len(),
                flags | fcntl_flags,
                // NOTE: Short-term solution to allow namespace management.
                // In the long term, we need to figure out how we should best handle
                // Unix permissions using capabilities.
                euid as usize,
                egid as usize,
            )
        }
    }

    /// Remove a file at at specific path
    pub fn unlinkat<T: AsRef<str>>(fd: usize, path: T, flags: usize) -> error::Result<usize> {
        let path = path.as_ref();
        unsafe {
            syscall4(
                number::SYS_UNLINKAT,
                fd,
                path.as_ptr() as usize,
                path.len(),
                flags,
            )
        }
    }

    /// Remove a file at at specific path with filter
    pub fn unlinkat_with_filter<T: AsRef<str>>(
        fd: usize,
        path: T,
        flags: usize,
        euid: u32,
        egid: u32,
    ) -> error::Result<usize> {
        let path = path.as_ref();
        unsafe {
            syscall6(
                number::SYS_UNLINKAT_WITH_FILTER,
                fd,
                path.as_ptr() as usize,
                path.len(),
                flags,
                // NOTE: Short-term solution to allow namespace management.
                // In the long term, we need to figure out how we should best handle
                // Unix permissions using capabilities.
                euid as usize,
                egid as usize,
            )
        }
    }

    /// Read from a file descriptor into a buffer
    pub fn read(fd: usize, buf: &mut [u8]) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_READ, fd, buf.as_mut_ptr() as usize, buf.len()) }
    }

    /// Write a buffer to a file descriptor
    ///
    /// The kernel will attempt to write the bytes in `buf` to the file descriptor `fd`, returning
    /// either an `Err`, explained below, or `Ok(count)` where `count` is the number of bytes which
    /// were written.
    ///
    /// # Errors
    ///
    /// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block
    /// * `EBADF` - the file descriptor is not valid or is not open for writing
    /// * `EFAULT` - `buf` does not point to the process's addressible memory
    /// * `EIO` - an I/O error occurred
    /// * `ENOSPC` - the device containing the file descriptor has no room for data
    /// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed
    pub fn write(fd: usize, buf: &[u8]) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_WRITE, fd, buf.as_ptr() as usize, buf.len()) }
    }

    /// Yield the process's time slice to the kernel
    ///
    /// This function will return Ok(0) on success
    pub fn sched_yield() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_YIELD) }
    }

    /// Send a file descriptor `fd`, handled by the scheme providing `receiver_socket`. `flags` is
    /// currently unused (must be zero), and `arg` is included in the scheme call.
    ///
    /// The scheme can return an arbitrary value.
    pub fn sendfd(
        receiver_socket: usize,
        fd: usize,
        flags: usize,
        arg: u64,
    ) -> error::Result<usize> {
        #[cfg(target_pointer_width = "32")]
        unsafe {
            syscall5(
                number::SYS_SENDFD,
                receiver_socket,
                fd,
                flags,
                arg as u32 as usize,
                (arg >> 32) as u32 as usize,
            )
        }

        #[cfg(target_pointer_width = "64")]
        unsafe {
            syscall4(number::SYS_SENDFD, receiver_socket, fd, flags, arg as usize)
        }
    }

    /// SYS_CALL interface, read-only variant
    pub fn call_ro(
        fd: usize,
        payload: &mut [u8],
        flags: flag::CallFlags,
        metadata: &[u64],
    ) -> error::Result<usize> {
        let combined_flags = flags | flag::CallFlags::READ;
        unsafe {
            syscall5(
                number::SYS_CALL,
                fd,
                payload.as_mut_ptr() as usize,
                payload.len(),
                metadata.len() | combined_flags.bits() as usize,
                metadata.as_ptr() as usize,
            )
        }
    }

    /// SYS_CALL interface, write-only variant
    pub fn call_wo(
        fd: usize,
        payload: &[u8],
        flags: flag::CallFlags,
        metadata: &[u64],
    ) -> error::Result<usize> {
        let combined_flags = flags | flag::CallFlags::WRITE;
        unsafe {
            syscall5(
                number::SYS_CALL,
                fd,
                payload.as_ptr() as *mut u8 as usize,
                payload.len(),
                metadata.len() | combined_flags.bits() as usize,
                metadata.as_ptr() as usize,
            )
        }
    }

    /// SYS_CALL interface, read-write variant
    pub fn call_rw(
        fd: usize,
        payload: &mut [u8],
        flags: flag::CallFlags,
        metadata: &[u64],
    ) -> error::Result<usize> {
        let combined_flags = flags | flag::CallFlags::READ | flag::CallFlags::WRITE;
        unsafe {
            syscall5(
                number::SYS_CALL,
                fd,
                payload.as_mut_ptr() as usize,
                payload.len(),
                metadata.len() | combined_flags.bits() as usize,
                metadata.as_ptr() as usize,
            )
        }
    }
}
