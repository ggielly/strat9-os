#![no_std]

// Architecture-specific definitions
pub mod arch;
pub use arch::*;

// Complex structures that are used for some system calls
pub mod data;
pub use data::*;

// All errors that can be generated by a system call
pub mod error;
pub use error::*;

// Flags used as an argument to many system calls
pub mod flag;
pub use flag::*;

// Functions for low level hardware control
pub mod io;
pub use io::*;

// Call numbers used by each system call
pub mod number;
pub use number::*;

// ABI for shared memory based signals
pub mod sigabi;
pub use sigabi::*;

// V2 scheme format
pub mod schemev2;
pub use schemev2::*;

// Directory entries
pub mod dirent;
pub use dirent::*;

// High-level call functions are defined inline below (after syscall0..6).

// ---------------------------------------------------------------------------
// Syscall raw invocation functions (x86_64 syscall ABI)
// ---------------------------------------------------------------------------
// Instead of a deeply-nested macro (which recent Rust nightlies have trouble
// parsing), each function is written out explicitly. There are only 7 variants
// (0..6 arguments) so the duplication is negligible and much more readable.

#[cfg(feature = "userspace")]
pub unsafe fn syscall0(mut a: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall1(mut a: usize, b: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall4(
    mut a: usize,
    b: usize,
    c: usize,
    d: usize,
    e: usize,
) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        in("r10") e,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall5(
    mut a: usize,
    b: usize,
    c: usize,
    d: usize,
    e: usize,
    f: usize,
) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        in("r10") e,
        in("r8") f,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

#[cfg(feature = "userspace")]
pub unsafe fn syscall6(
    mut a: usize,
    b: usize,
    c: usize,
    d: usize,
    e: usize,
    f: usize,
    g: usize,
) -> error::Result<usize> {
    core::arch::asm!(
        "syscall",
        inout("rax") a,
        in("rdi") b,
        in("rsi") c,
        in("rdx") d,
        in("r10") e,
        in("r8") f,
        in("r9") g,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    error::Error::demux(a)
}

// High-level syscall functions
#[cfg(feature = "userspace")]
pub mod call {
    use super::*;
    const MAP_PRIVATE: usize = 1 << 1;
    const MAP_ANONYMOUS: usize = 1 << 5;
    pub const WNOHANG: usize = 1;

    const FUTEX_WAIT: usize = 0;
    const FUTEX_WAKE: usize = 1;
    const FUTEX_REQUEUE: usize = 3;
    const FUTEX_CMP_REQUEUE: usize = 4;
    const FUTEX_WAKE_OP: usize = 5;

    /// Close a file
    pub fn close(fd: usize) -> error::Result<usize> {
        unsafe { syscall1(number::SYS_CLOSE, fd) }
    }

    /// Get the current system time
    pub fn clock_gettime(clock: usize, tp: &mut data::TimeSpec) -> error::Result<usize> {
        unsafe {
            syscall2(
                number::SYS_CLOCK_GETTIME,
                clock,
                tp as *mut data::TimeSpec as usize,
            )
        }
    }

    /// Copy and transform a file descriptor
    pub fn dup(fd: usize, buf: &[u8]) -> error::Result<usize> {
        let _ = buf;
        unsafe { syscall1(number::SYS_HANDLE_DUPLICATE, fd) }
    }

    /// Copy and transform a file descriptor
    pub fn dup2(fd: usize, newfd: usize, buf: &[u8]) -> error::Result<usize> {
        let _ = (fd, newfd, buf);
        Err(error::Error::NotSupported)
    }

    /// Change file permissions
    pub fn fchmod(fd: usize, mode: u16) -> error::Result<usize> {
        let _ = (fd, mode);
        Err(error::Error::NotSupported)
    }

    /// Change file ownership
    pub fn fchown(fd: usize, uid: u32, gid: u32) -> error::Result<usize> {
        let _ = (fd, uid, gid);
        Err(error::Error::NotSupported)
    }

    /// Change file descriptor flags
    pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_FCNTL, fd, cmd, arg) }
    }

    /// Map a file into memory, but with the ability to set the address to map into, either as a hint
    /// or as a requirement of the map.
    ///
    /// # Errors
    /// `EACCES` - the file descriptor was not open for reading
    /// `EBADF` - if the file descriptor was invalid
    /// `ENODEV` - mmapping was not supported
    /// `EINVAL` - invalid combination of flags
    /// `EEXIST` - if [`MapFlags::MAP_FIXED`] was set, and the address specified was already in use.
    ///
    pub unsafe fn fmap(fd: usize, map: &data::Map) -> error::Result<usize> {
        // ABI v2 exposes SYS_MMAP directly: (addr, len, prot, flags, fd, offset).
        let prot = (map.flags as usize) & 0x7;
        let mut flags = map.flags as usize;
        // Ensure kernel-required anonymous private default for legacy callers.
        if flags & (1 << 0 | MAP_PRIVATE) == 0 {
            flags |= MAP_PRIVATE;
        }
        flags |= MAP_ANONYMOUS;
        syscall6(
            number::SYS_MMAP,
            map.addr,
            map.size,
            prot,
            flags,
            fd,
            map.offset,
        )
    }

    /// Unmap whole (or partial) continous memory-mapped files
    pub unsafe fn funmap(addr: usize, len: usize) -> error::Result<usize> {
        syscall2(number::SYS_MUNMAP, addr, len)
    }

    /// Retrieve the canonical path of a file
    pub fn fpath(fd: usize, buf: &mut [u8]) -> error::Result<usize> {
        let _ = (fd, buf);
        Err(error::Error::NotSupported)
    }

    /// Create a link to a file
    pub fn flink<T: AsRef<str>>(fd: usize, path: T) -> error::Result<usize> {
        let _ = (fd, path.as_ref());
        Err(error::Error::NotSupported)
    }

    /// Rename a file
    pub fn frename<T: AsRef<str>>(fd: usize, path: T) -> error::Result<usize> {
        let _ = (fd, path.as_ref());
        Err(error::Error::NotSupported)
    }

    /// Get metadata about a file
    pub fn fstat(fd: usize, stat: &mut data::Stat) -> error::Result<usize> {
        let _ = (fd, stat);
        Err(error::Error::NotSupported)
    }

    /// Get metadata about a filesystem
    pub fn fstatvfs(fd: usize, stat: &mut data::StatVfs) -> error::Result<usize> {
        let _ = (fd, stat);
        Err(error::Error::NotSupported)
    }

    /// Sync a file descriptor to its underlying medium
    pub fn fsync(fd: usize) -> error::Result<usize> {
        let _ = fd;
        Err(error::Error::NotSupported)
    }

    /// Truncate or extend a file to a specified length
    pub fn ftruncate(fd: usize, len: usize) -> error::Result<usize> {
        let _ = (fd, len);
        Err(error::Error::NotSupported)
    }

    // Change modify and/or access times
    pub fn futimens(fd: usize, times: &[data::TimeSpec]) -> error::Result<usize> {
        let _ = (fd, times);
        Err(error::Error::NotSupported)
    }

    /// Fast userspace mutex
    pub unsafe fn futex(
        addr: *mut i32,
        op: usize,
        val: i32,
        val2: usize,
        addr2: *mut i32,
    ) -> error::Result<usize> {
        match op {
            FUTEX_WAIT => syscall3(number::SYS_FUTEX_WAIT, addr as usize, val as usize, val2),
            FUTEX_WAKE => syscall2(number::SYS_FUTEX_WAKE, addr as usize, val as usize),
            FUTEX_REQUEUE => syscall4(
                number::SYS_FUTEX_REQUEUE,
                addr as usize,
                val as usize,
                val2,
                addr2 as usize,
            ),
            FUTEX_CMP_REQUEUE => syscall5(
                number::SYS_FUTEX_CMP_REQUEUE,
                addr as usize,
                val as usize,
                val2,
                addr2 as usize,
                0,
            ),
            FUTEX_WAKE_OP => syscall5(
                number::SYS_FUTEX_WAKE_OP,
                addr as usize,
                val as usize,
                val2,
                addr2 as usize,
                0,
            ),
            _ => Err(error::Error::Invalid),
        }
    }

    /// Seek to `offset` bytes in a file descriptor
    pub fn lseek(fd: usize, offset: isize, whence: usize) -> error::Result<usize> {
        let _ = (fd, offset, whence);
        Err(error::Error::NotSupported)
    }

    /// Make a new scheme namespace
    pub fn mkns(schemes: &[[usize; 2]]) -> error::Result<usize> {
        let _ = schemes;
        Err(error::Error::NotSupported)
    }

    /// Change mapping flags
    pub unsafe fn mprotect(
        addr: usize,
        size: usize,
        flags: flag::MapFlags,
    ) -> error::Result<usize> {
        syscall3(number::SYS_MPROTECT, addr, size, flags.bits() as usize)
    }

    /// Sleep for the time specified in `req`
    pub fn nanosleep(req: &data::TimeSpec, rem: &mut data::TimeSpec) -> error::Result<usize> {
        unsafe {
            syscall2(
                number::SYS_NANOSLEEP,
                req as *const data::TimeSpec as usize,
                rem as *mut data::TimeSpec as usize,
            )
        }
    }

    /// Open a file at a specific path
    pub fn openat<T: AsRef<str>>(
        fd: usize,
        path: T,
        flags: usize,
        fcntl_flags: usize,
    ) -> error::Result<usize> {
        let _ = fd;
        let path = path.as_ref();
        unsafe {
            syscall3(
                number::SYS_OPEN,
                path.as_ptr() as usize,
                path.len(),
                flags | fcntl_flags,
            )
        }
    }

    /// Open a file at a specific path with filter
    pub fn openat_with_filter<T: AsRef<str>>(
        fd: usize,
        path: T,
        flags: usize,
        fcntl_flags: usize,
        euid: u32,
        egid: u32,
    ) -> error::Result<usize> {
        let _ = (euid, egid);
        openat(fd, path, flags, fcntl_flags)
    }

    /// Remove a file at at specific path
    pub fn unlinkat<T: AsRef<str>>(fd: usize, path: T, flags: usize) -> error::Result<usize> {
        let _ = (fd, path.as_ref(), flags);
        Err(error::Error::NotSupported)
    }

    /// Remove a file at at specific path with filter
    pub fn unlinkat_with_filter<T: AsRef<str>>(
        fd: usize,
        path: T,
        flags: usize,
        euid: u32,
        egid: u32,
    ) -> error::Result<usize> {
        let _ = (euid, egid);
        unlinkat(fd, path, flags)
    }

    /// Read from a file descriptor into a buffer
    pub fn read(fd: usize, buf: &mut [u8]) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_READ, fd, buf.as_mut_ptr() as usize, buf.len()) }
    }

    /// Write a buffer to a file descriptor
    ///
    /// The kernel will attempt to write the bytes in `buf` to the file descriptor `fd`, returning
    /// either an `Err`, explained below, or `Ok(count)` where `count` is the number of bytes which
    /// were written.
    ///
    /// # Errors
    ///
    /// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block
    /// * `EBADF` - the file descriptor is not valid or is not open for writing
    /// * `EFAULT` - `buf` does not point to the process's addressible memory
    /// * `EIO` - an I/O error occurred
    /// * `ENOSPC` - the device containing the file descriptor has no room for data
    /// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed
    pub fn write(fd: usize, buf: &[u8]) -> error::Result<usize> {
        unsafe { syscall3(number::SYS_WRITE, fd, buf.as_ptr() as usize, buf.len()) }
    }

    /// Terminate the current process with the given exit `code`.
    ///
    /// This function never returns.
    pub fn exit(code: usize) -> ! {
        unsafe {
            syscall1(number::SYS_PROC_EXIT, code).ok();
        }
        #[allow(clippy::empty_loop)]
        loop {
            core::hint::spin_loop();
        }
    }

    /// Yield the process's time slice to the kernel
    ///
    /// This function will return Ok(0) on success
    pub fn sched_yield() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_PROC_YIELD) }
    }

    /// Fork the current process.
    ///
    /// Returns child PID in parent, and 0 in child.
    pub fn fork() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_PROC_FORK) }
    }

    /// Replace the current process image with a new program.
    ///
    /// `path`: executable path as a byte slice.
    /// `argv` and `envp`: pointers to null-terminated C-style arrays.
    pub unsafe fn execve(
        path: &[u8],
        argv: usize,
        envp: usize,
    ) -> error::Result<usize> {
        syscall5(
            number::SYS_PROC_EXECVE,
            path.as_ptr() as usize,
            path.len(),
            argv,
            envp,
            0,
        )
    }

    /// Return current process ID.
    pub fn getpid() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_GETPID) }
    }

    /// Return current thread ID.
    pub fn gettid() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_GETTID) }
    }

    /// Return parent process ID.
    pub fn getppid() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_GETPPID) }
    }

    /// Wait for a child process (raw, single attempt).
    ///
    /// `pid` supports POSIX values (`-1` = any child).
    /// `status` receives encoded wait status (same layout as Linux waitpid).
    ///
    /// Prefer [`waitpid_blocking`] for blocking waits â€” it automatically
    /// retries on `EINTR`.
    pub fn waitpid(pid: isize, status: Option<&mut i32>, options: usize) -> error::Result<usize> {
        let status_ptr = status.map_or(0usize, |s| s as *mut i32 as usize);
        unsafe { syscall3(number::SYS_PROC_WAITPID, pid as usize, status_ptr, options) }
    }

    /// Wait for a child process, automatically retrying on `EINTR`.
    ///
    /// This is the recommended wrapper for blocking waits. It calls
    /// [`waitpid`] in a loop and yields the CPU between retries when
    /// the kernel interrupts the wait with `EINTR`.
    pub fn waitpid_blocking(pid: isize, status: &mut i32) -> error::Result<usize> {
        loop {
            match waitpid(pid, Some(status), 0) {
                Err(error::Error::Interrupted) => {
                    let _ = sched_yield();
                }
                other => return other,
            }
        }
    }

    /// Set process group ID.
    ///
    /// `pid == 0` targets the current process, `pgid == 0` uses target pid.
    pub fn setpgid(pid: isize, pgid: isize) -> error::Result<usize> {
        unsafe { syscall2(number::SYS_SETPGID, pid as usize, pgid as usize) }
    }

    /// Return process group ID.
    ///
    /// `pid == 0` queries current process group.
    pub fn getpgid(pid: isize) -> error::Result<usize> {
        unsafe { syscall1(number::SYS_GETPGID, pid as usize) }
    }

    /// Create a new session and return its session ID.
    pub fn setsid() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_SETSID) }
    }

    /// Return session ID for `pid` (`0` = current process).
    pub fn getsid(pid: isize) -> error::Result<usize> {
        unsafe { syscall1(number::SYS_GETSID, pid as usize) }
    }

    /// Return current process group ID.
    pub fn getpgrp() -> error::Result<usize> {
        unsafe { syscall0(number::SYS_GETPGRP) }
    }

    /// Send a file descriptor `fd`, handled by the scheme providing `receiver_socket`. `flags` is
    /// currently unused (must be zero), and `arg` is included in the scheme call.
    ///
    /// The scheme can return an arbitrary value.
    pub fn sendfd(
        receiver_socket: usize,
        fd: usize,
        flags: usize,
        arg: u64,
    ) -> error::Result<usize> {
        let _ = (receiver_socket, fd, flags, arg);
        Err(error::Error::NotSupported)
    }

    /// SYS_CALL interface, read-only variant
    pub fn call_ro(
        fd: usize,
        payload: &mut [u8],
        flags: flag::CallFlags,
        metadata: &[u64],
    ) -> error::Result<usize> {
        let _ = (fd, payload, flags, metadata);
        Err(error::Error::NotSupported)
    }

    /// SYS_CALL interface, write-only variant
    pub fn call_wo(
        fd: usize,
        payload: &[u8],
        flags: flag::CallFlags,
        metadata: &[u64],
    ) -> error::Result<usize> {
        let _ = (fd, payload, flags, metadata);
        Err(error::Error::NotSupported)
    }

    /// SYS_CALL interface, read-write variant
    pub fn call_rw(
        fd: usize,
        payload: &mut [u8],
        flags: flag::CallFlags,
        metadata: &[u64],
    ) -> error::Result<usize> {
        let _ = (fd, payload, flags, metadata);
        Err(error::Error::NotSupported)
    }
}
